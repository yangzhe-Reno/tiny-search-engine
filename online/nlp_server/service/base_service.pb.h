// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: base_service.proto

#ifndef PROTOBUF_INCLUDED_base_5fservice_2eproto
#define PROTOBUF_INCLUDED_base_5fservice_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/service.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_base_5fservice_2eproto 

namespace protobuf_base_5fservice_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[7];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_base_5fservice_2eproto
namespace NLP {
class RecallRequest;
class RecallRequestDefaultTypeInternal;
extern RecallRequestDefaultTypeInternal _RecallRequest_default_instance_;
class RecallResponse;
class RecallResponseDefaultTypeInternal;
extern RecallResponseDefaultTypeInternal _RecallResponse_default_instance_;
class SegmentRequest;
class SegmentRequestDefaultTypeInternal;
extern SegmentRequestDefaultTypeInternal _SegmentRequest_default_instance_;
class SegmentResponse;
class SegmentResponseDefaultTypeInternal;
extern SegmentResponseDefaultTypeInternal _SegmentResponse_default_instance_;
class SegmentResult;
class SegmentResultDefaultTypeInternal;
extern SegmentResultDefaultTypeInternal _SegmentResult_default_instance_;
class SortRequest;
class SortRequestDefaultTypeInternal;
extern SortRequestDefaultTypeInternal _SortRequest_default_instance_;
class SortResponse;
class SortResponseDefaultTypeInternal;
extern SortResponseDefaultTypeInternal _SortResponse_default_instance_;
}  // namespace NLP
namespace google {
namespace protobuf {
template<> ::NLP::RecallRequest* Arena::CreateMaybeMessage<::NLP::RecallRequest>(Arena*);
template<> ::NLP::RecallResponse* Arena::CreateMaybeMessage<::NLP::RecallResponse>(Arena*);
template<> ::NLP::SegmentRequest* Arena::CreateMaybeMessage<::NLP::SegmentRequest>(Arena*);
template<> ::NLP::SegmentResponse* Arena::CreateMaybeMessage<::NLP::SegmentResponse>(Arena*);
template<> ::NLP::SegmentResult* Arena::CreateMaybeMessage<::NLP::SegmentResult>(Arena*);
template<> ::NLP::SortRequest* Arena::CreateMaybeMessage<::NLP::SortRequest>(Arena*);
template<> ::NLP::SortResponse* Arena::CreateMaybeMessage<::NLP::SortResponse>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace NLP {

// ===================================================================

class SegmentResult : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NLP.SegmentResult) */ {
 public:
  SegmentResult();
  virtual ~SegmentResult();

  SegmentResult(const SegmentResult& from);

  inline SegmentResult& operator=(const SegmentResult& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SegmentResult(SegmentResult&& from) noexcept
    : SegmentResult() {
    *this = ::std::move(from);
  }

  inline SegmentResult& operator=(SegmentResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SegmentResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SegmentResult* internal_default_instance() {
    return reinterpret_cast<const SegmentResult*>(
               &_SegmentResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(SegmentResult* other);
  friend void swap(SegmentResult& a, SegmentResult& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SegmentResult* New() const final {
    return CreateMaybeMessage<SegmentResult>(NULL);
  }

  SegmentResult* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SegmentResult>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SegmentResult& from);
  void MergeFrom(const SegmentResult& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SegmentResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string token = 1;
  bool has_token() const;
  void clear_token();
  static const int kTokenFieldNumber = 1;
  const ::std::string& token() const;
  void set_token(const ::std::string& value);
  #if LANG_CXX11
  void set_token(::std::string&& value);
  #endif
  void set_token(const char* value);
  void set_token(const char* value, size_t size);
  ::std::string* mutable_token();
  ::std::string* release_token();
  void set_allocated_token(::std::string* token);

  // required int32 TF = 2;
  bool has_tf() const;
  void clear_tf();
  static const int kTFFieldNumber = 2;
  ::google::protobuf::int32 tf() const;
  void set_tf(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:NLP.SegmentResult)
 private:
  void set_has_token();
  void clear_has_token();
  void set_has_tf();
  void clear_has_tf();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr token_;
  ::google::protobuf::int32 tf_;
  friend struct ::protobuf_base_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SegmentRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NLP.SegmentRequest) */ {
 public:
  SegmentRequest();
  virtual ~SegmentRequest();

  SegmentRequest(const SegmentRequest& from);

  inline SegmentRequest& operator=(const SegmentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SegmentRequest(SegmentRequest&& from) noexcept
    : SegmentRequest() {
    *this = ::std::move(from);
  }

  inline SegmentRequest& operator=(SegmentRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SegmentRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SegmentRequest* internal_default_instance() {
    return reinterpret_cast<const SegmentRequest*>(
               &_SegmentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(SegmentRequest* other);
  friend void swap(SegmentRequest& a, SegmentRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SegmentRequest* New() const final {
    return CreateMaybeMessage<SegmentRequest>(NULL);
  }

  SegmentRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SegmentRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SegmentRequest& from);
  void MergeFrom(const SegmentRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SegmentRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string sentence = 1;
  bool has_sentence() const;
  void clear_sentence();
  static const int kSentenceFieldNumber = 1;
  const ::std::string& sentence() const;
  void set_sentence(const ::std::string& value);
  #if LANG_CXX11
  void set_sentence(::std::string&& value);
  #endif
  void set_sentence(const char* value);
  void set_sentence(const char* value, size_t size);
  ::std::string* mutable_sentence();
  ::std::string* release_sentence();
  void set_allocated_sentence(::std::string* sentence);

  // @@protoc_insertion_point(class_scope:NLP.SegmentRequest)
 private:
  void set_has_sentence();
  void clear_has_sentence();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr sentence_;
  friend struct ::protobuf_base_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SegmentResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NLP.SegmentResponse) */ {
 public:
  SegmentResponse();
  virtual ~SegmentResponse();

  SegmentResponse(const SegmentResponse& from);

  inline SegmentResponse& operator=(const SegmentResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SegmentResponse(SegmentResponse&& from) noexcept
    : SegmentResponse() {
    *this = ::std::move(from);
  }

  inline SegmentResponse& operator=(SegmentResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SegmentResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SegmentResponse* internal_default_instance() {
    return reinterpret_cast<const SegmentResponse*>(
               &_SegmentResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(SegmentResponse* other);
  friend void swap(SegmentResponse& a, SegmentResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SegmentResponse* New() const final {
    return CreateMaybeMessage<SegmentResponse>(NULL);
  }

  SegmentResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SegmentResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SegmentResponse& from);
  void MergeFrom(const SegmentResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SegmentResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .NLP.SegmentResult result = 1;
  int result_size() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::NLP::SegmentResult* mutable_result(int index);
  ::google::protobuf::RepeatedPtrField< ::NLP::SegmentResult >*
      mutable_result();
  const ::NLP::SegmentResult& result(int index) const;
  ::NLP::SegmentResult* add_result();
  const ::google::protobuf::RepeatedPtrField< ::NLP::SegmentResult >&
      result() const;

  // @@protoc_insertion_point(class_scope:NLP.SegmentResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::NLP::SegmentResult > result_;
  friend struct ::protobuf_base_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RecallRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NLP.RecallRequest) */ {
 public:
  RecallRequest();
  virtual ~RecallRequest();

  RecallRequest(const RecallRequest& from);

  inline RecallRequest& operator=(const RecallRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RecallRequest(RecallRequest&& from) noexcept
    : RecallRequest() {
    *this = ::std::move(from);
  }

  inline RecallRequest& operator=(RecallRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RecallRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RecallRequest* internal_default_instance() {
    return reinterpret_cast<const RecallRequest*>(
               &_RecallRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(RecallRequest* other);
  friend void swap(RecallRequest& a, RecallRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RecallRequest* New() const final {
    return CreateMaybeMessage<RecallRequest>(NULL);
  }

  RecallRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RecallRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RecallRequest& from);
  void MergeFrom(const RecallRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RecallRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string tokens = 1;
  int tokens_size() const;
  void clear_tokens();
  static const int kTokensFieldNumber = 1;
  const ::std::string& tokens(int index) const;
  ::std::string* mutable_tokens(int index);
  void set_tokens(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_tokens(int index, ::std::string&& value);
  #endif
  void set_tokens(int index, const char* value);
  void set_tokens(int index, const char* value, size_t size);
  ::std::string* add_tokens();
  void add_tokens(const ::std::string& value);
  #if LANG_CXX11
  void add_tokens(::std::string&& value);
  #endif
  void add_tokens(const char* value);
  void add_tokens(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& tokens() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_tokens();

  // @@protoc_insertion_point(class_scope:NLP.RecallRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> tokens_;
  friend struct ::protobuf_base_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RecallResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NLP.RecallResponse) */ {
 public:
  RecallResponse();
  virtual ~RecallResponse();

  RecallResponse(const RecallResponse& from);

  inline RecallResponse& operator=(const RecallResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RecallResponse(RecallResponse&& from) noexcept
    : RecallResponse() {
    *this = ::std::move(from);
  }

  inline RecallResponse& operator=(RecallResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RecallResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RecallResponse* internal_default_instance() {
    return reinterpret_cast<const RecallResponse*>(
               &_RecallResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(RecallResponse* other);
  friend void swap(RecallResponse& a, RecallResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RecallResponse* New() const final {
    return CreateMaybeMessage<RecallResponse>(NULL);
  }

  RecallResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RecallResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RecallResponse& from);
  void MergeFrom(const RecallResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RecallResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 DocIds = 1;
  int docids_size() const;
  void clear_docids();
  static const int kDocIdsFieldNumber = 1;
  ::google::protobuf::int32 docids(int index) const;
  void set_docids(int index, ::google::protobuf::int32 value);
  void add_docids(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      docids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_docids();

  // @@protoc_insertion_point(class_scope:NLP.RecallResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > docids_;
  friend struct ::protobuf_base_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SortRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NLP.SortRequest) */ {
 public:
  SortRequest();
  virtual ~SortRequest();

  SortRequest(const SortRequest& from);

  inline SortRequest& operator=(const SortRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SortRequest(SortRequest&& from) noexcept
    : SortRequest() {
    *this = ::std::move(from);
  }

  inline SortRequest& operator=(SortRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SortRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SortRequest* internal_default_instance() {
    return reinterpret_cast<const SortRequest*>(
               &_SortRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(SortRequest* other);
  friend void swap(SortRequest& a, SortRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SortRequest* New() const final {
    return CreateMaybeMessage<SortRequest>(NULL);
  }

  SortRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SortRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SortRequest& from);
  void MergeFrom(const SortRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SortRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .NLP.SegmentResult cut_result = 1;
  int cut_result_size() const;
  void clear_cut_result();
  static const int kCutResultFieldNumber = 1;
  ::NLP::SegmentResult* mutable_cut_result(int index);
  ::google::protobuf::RepeatedPtrField< ::NLP::SegmentResult >*
      mutable_cut_result();
  const ::NLP::SegmentResult& cut_result(int index) const;
  ::NLP::SegmentResult* add_cut_result();
  const ::google::protobuf::RepeatedPtrField< ::NLP::SegmentResult >&
      cut_result() const;

  // repeated int32 DocIds = 2;
  int docids_size() const;
  void clear_docids();
  static const int kDocIdsFieldNumber = 2;
  ::google::protobuf::int32 docids(int index) const;
  void set_docids(int index, ::google::protobuf::int32 value);
  void add_docids(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      docids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_docids();

  // @@protoc_insertion_point(class_scope:NLP.SortRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::NLP::SegmentResult > cut_result_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > docids_;
  friend struct ::protobuf_base_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SortResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NLP.SortResponse) */ {
 public:
  SortResponse();
  virtual ~SortResponse();

  SortResponse(const SortResponse& from);

  inline SortResponse& operator=(const SortResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SortResponse(SortResponse&& from) noexcept
    : SortResponse() {
    *this = ::std::move(from);
  }

  inline SortResponse& operator=(SortResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SortResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SortResponse* internal_default_instance() {
    return reinterpret_cast<const SortResponse*>(
               &_SortResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(SortResponse* other);
  friend void swap(SortResponse& a, SortResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SortResponse* New() const final {
    return CreateMaybeMessage<SortResponse>(NULL);
  }

  SortResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SortResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SortResponse& from);
  void MergeFrom(const SortResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SortResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 DocIds = 1;
  int docids_size() const;
  void clear_docids();
  static const int kDocIdsFieldNumber = 1;
  ::google::protobuf::int32 docids(int index) const;
  void set_docids(int index, ::google::protobuf::int32 value);
  void add_docids(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      docids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_docids();

  // @@protoc_insertion_point(class_scope:NLP.SortResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > docids_;
  friend struct ::protobuf_base_5fservice_2eproto::TableStruct;
};
// ===================================================================

class SegmentService_Stub;

class SegmentService : public ::google::protobuf::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline SegmentService() {};
 public:
  virtual ~SegmentService();

  typedef SegmentService_Stub Stub;

  static const ::google::protobuf::ServiceDescriptor* descriptor();

  virtual void cut(::google::protobuf::RpcController* controller,
                       const ::NLP::SegmentRequest* request,
                       ::NLP::SegmentResponse* response,
                       ::google::protobuf::Closure* done);

  // implements Service ----------------------------------------------

  const ::google::protobuf::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::google::protobuf::MethodDescriptor* method,
                  ::google::protobuf::RpcController* controller,
                  const ::google::protobuf::Message* request,
                  ::google::protobuf::Message* response,
                  ::google::protobuf::Closure* done);
  const ::google::protobuf::Message& GetRequestPrototype(
    const ::google::protobuf::MethodDescriptor* method) const;
  const ::google::protobuf::Message& GetResponsePrototype(
    const ::google::protobuf::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(SegmentService);
};

class SegmentService_Stub : public SegmentService {
 public:
  SegmentService_Stub(::google::protobuf::RpcChannel* channel);
  SegmentService_Stub(::google::protobuf::RpcChannel* channel,
                   ::google::protobuf::Service::ChannelOwnership ownership);
  ~SegmentService_Stub();

  inline ::google::protobuf::RpcChannel* channel() { return channel_; }

  // implements SegmentService ------------------------------------------

  void cut(::google::protobuf::RpcController* controller,
                       const ::NLP::SegmentRequest* request,
                       ::NLP::SegmentResponse* response,
                       ::google::protobuf::Closure* done);
 private:
  ::google::protobuf::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(SegmentService_Stub);
};


// -------------------------------------------------------------------

class RecallService_Stub;

class RecallService : public ::google::protobuf::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline RecallService() {};
 public:
  virtual ~RecallService();

  typedef RecallService_Stub Stub;

  static const ::google::protobuf::ServiceDescriptor* descriptor();

  virtual void recall(::google::protobuf::RpcController* controller,
                       const ::NLP::RecallRequest* request,
                       ::NLP::RecallResponse* response,
                       ::google::protobuf::Closure* done);

  // implements Service ----------------------------------------------

  const ::google::protobuf::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::google::protobuf::MethodDescriptor* method,
                  ::google::protobuf::RpcController* controller,
                  const ::google::protobuf::Message* request,
                  ::google::protobuf::Message* response,
                  ::google::protobuf::Closure* done);
  const ::google::protobuf::Message& GetRequestPrototype(
    const ::google::protobuf::MethodDescriptor* method) const;
  const ::google::protobuf::Message& GetResponsePrototype(
    const ::google::protobuf::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(RecallService);
};

class RecallService_Stub : public RecallService {
 public:
  RecallService_Stub(::google::protobuf::RpcChannel* channel);
  RecallService_Stub(::google::protobuf::RpcChannel* channel,
                   ::google::protobuf::Service::ChannelOwnership ownership);
  ~RecallService_Stub();

  inline ::google::protobuf::RpcChannel* channel() { return channel_; }

  // implements RecallService ------------------------------------------

  void recall(::google::protobuf::RpcController* controller,
                       const ::NLP::RecallRequest* request,
                       ::NLP::RecallResponse* response,
                       ::google::protobuf::Closure* done);
 private:
  ::google::protobuf::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(RecallService_Stub);
};


// -------------------------------------------------------------------

class SortService_Stub;

class SortService : public ::google::protobuf::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline SortService() {};
 public:
  virtual ~SortService();

  typedef SortService_Stub Stub;

  static const ::google::protobuf::ServiceDescriptor* descriptor();

  virtual void sort(::google::protobuf::RpcController* controller,
                       const ::NLP::SortRequest* request,
                       ::NLP::SortResponse* response,
                       ::google::protobuf::Closure* done);

  // implements Service ----------------------------------------------

  const ::google::protobuf::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::google::protobuf::MethodDescriptor* method,
                  ::google::protobuf::RpcController* controller,
                  const ::google::protobuf::Message* request,
                  ::google::protobuf::Message* response,
                  ::google::protobuf::Closure* done);
  const ::google::protobuf::Message& GetRequestPrototype(
    const ::google::protobuf::MethodDescriptor* method) const;
  const ::google::protobuf::Message& GetResponsePrototype(
    const ::google::protobuf::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(SortService);
};

class SortService_Stub : public SortService {
 public:
  SortService_Stub(::google::protobuf::RpcChannel* channel);
  SortService_Stub(::google::protobuf::RpcChannel* channel,
                   ::google::protobuf::Service::ChannelOwnership ownership);
  ~SortService_Stub();

  inline ::google::protobuf::RpcChannel* channel() { return channel_; }

  // implements SortService ------------------------------------------

  void sort(::google::protobuf::RpcController* controller,
                       const ::NLP::SortRequest* request,
                       ::NLP::SortResponse* response,
                       ::google::protobuf::Closure* done);
 private:
  ::google::protobuf::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(SortService_Stub);
};


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SegmentResult

// required string token = 1;
inline bool SegmentResult::has_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SegmentResult::set_has_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SegmentResult::clear_has_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SegmentResult::clear_token() {
  token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_token();
}
inline const ::std::string& SegmentResult::token() const {
  // @@protoc_insertion_point(field_get:NLP.SegmentResult.token)
  return token_.GetNoArena();
}
inline void SegmentResult::set_token(const ::std::string& value) {
  set_has_token();
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NLP.SegmentResult.token)
}
#if LANG_CXX11
inline void SegmentResult::set_token(::std::string&& value) {
  set_has_token();
  token_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NLP.SegmentResult.token)
}
#endif
inline void SegmentResult::set_token(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_token();
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NLP.SegmentResult.token)
}
inline void SegmentResult::set_token(const char* value, size_t size) {
  set_has_token();
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NLP.SegmentResult.token)
}
inline ::std::string* SegmentResult::mutable_token() {
  set_has_token();
  // @@protoc_insertion_point(field_mutable:NLP.SegmentResult.token)
  return token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SegmentResult::release_token() {
  // @@protoc_insertion_point(field_release:NLP.SegmentResult.token)
  if (!has_token()) {
    return NULL;
  }
  clear_has_token();
  return token_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SegmentResult::set_allocated_token(::std::string* token) {
  if (token != NULL) {
    set_has_token();
  } else {
    clear_has_token();
  }
  token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), token);
  // @@protoc_insertion_point(field_set_allocated:NLP.SegmentResult.token)
}

// required int32 TF = 2;
inline bool SegmentResult::has_tf() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SegmentResult::set_has_tf() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SegmentResult::clear_has_tf() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SegmentResult::clear_tf() {
  tf_ = 0;
  clear_has_tf();
}
inline ::google::protobuf::int32 SegmentResult::tf() const {
  // @@protoc_insertion_point(field_get:NLP.SegmentResult.TF)
  return tf_;
}
inline void SegmentResult::set_tf(::google::protobuf::int32 value) {
  set_has_tf();
  tf_ = value;
  // @@protoc_insertion_point(field_set:NLP.SegmentResult.TF)
}

// -------------------------------------------------------------------

// SegmentRequest

// required string sentence = 1;
inline bool SegmentRequest::has_sentence() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SegmentRequest::set_has_sentence() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SegmentRequest::clear_has_sentence() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SegmentRequest::clear_sentence() {
  sentence_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sentence();
}
inline const ::std::string& SegmentRequest::sentence() const {
  // @@protoc_insertion_point(field_get:NLP.SegmentRequest.sentence)
  return sentence_.GetNoArena();
}
inline void SegmentRequest::set_sentence(const ::std::string& value) {
  set_has_sentence();
  sentence_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NLP.SegmentRequest.sentence)
}
#if LANG_CXX11
inline void SegmentRequest::set_sentence(::std::string&& value) {
  set_has_sentence();
  sentence_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NLP.SegmentRequest.sentence)
}
#endif
inline void SegmentRequest::set_sentence(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_sentence();
  sentence_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NLP.SegmentRequest.sentence)
}
inline void SegmentRequest::set_sentence(const char* value, size_t size) {
  set_has_sentence();
  sentence_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NLP.SegmentRequest.sentence)
}
inline ::std::string* SegmentRequest::mutable_sentence() {
  set_has_sentence();
  // @@protoc_insertion_point(field_mutable:NLP.SegmentRequest.sentence)
  return sentence_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SegmentRequest::release_sentence() {
  // @@protoc_insertion_point(field_release:NLP.SegmentRequest.sentence)
  if (!has_sentence()) {
    return NULL;
  }
  clear_has_sentence();
  return sentence_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SegmentRequest::set_allocated_sentence(::std::string* sentence) {
  if (sentence != NULL) {
    set_has_sentence();
  } else {
    clear_has_sentence();
  }
  sentence_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sentence);
  // @@protoc_insertion_point(field_set_allocated:NLP.SegmentRequest.sentence)
}

// -------------------------------------------------------------------

// SegmentResponse

// repeated .NLP.SegmentResult result = 1;
inline int SegmentResponse::result_size() const {
  return result_.size();
}
inline void SegmentResponse::clear_result() {
  result_.Clear();
}
inline ::NLP::SegmentResult* SegmentResponse::mutable_result(int index) {
  // @@protoc_insertion_point(field_mutable:NLP.SegmentResponse.result)
  return result_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NLP::SegmentResult >*
SegmentResponse::mutable_result() {
  // @@protoc_insertion_point(field_mutable_list:NLP.SegmentResponse.result)
  return &result_;
}
inline const ::NLP::SegmentResult& SegmentResponse::result(int index) const {
  // @@protoc_insertion_point(field_get:NLP.SegmentResponse.result)
  return result_.Get(index);
}
inline ::NLP::SegmentResult* SegmentResponse::add_result() {
  // @@protoc_insertion_point(field_add:NLP.SegmentResponse.result)
  return result_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NLP::SegmentResult >&
SegmentResponse::result() const {
  // @@protoc_insertion_point(field_list:NLP.SegmentResponse.result)
  return result_;
}

// -------------------------------------------------------------------

// RecallRequest

// repeated string tokens = 1;
inline int RecallRequest::tokens_size() const {
  return tokens_.size();
}
inline void RecallRequest::clear_tokens() {
  tokens_.Clear();
}
inline const ::std::string& RecallRequest::tokens(int index) const {
  // @@protoc_insertion_point(field_get:NLP.RecallRequest.tokens)
  return tokens_.Get(index);
}
inline ::std::string* RecallRequest::mutable_tokens(int index) {
  // @@protoc_insertion_point(field_mutable:NLP.RecallRequest.tokens)
  return tokens_.Mutable(index);
}
inline void RecallRequest::set_tokens(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:NLP.RecallRequest.tokens)
  tokens_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void RecallRequest::set_tokens(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:NLP.RecallRequest.tokens)
  tokens_.Mutable(index)->assign(std::move(value));
}
#endif
inline void RecallRequest::set_tokens(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  tokens_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:NLP.RecallRequest.tokens)
}
inline void RecallRequest::set_tokens(int index, const char* value, size_t size) {
  tokens_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NLP.RecallRequest.tokens)
}
inline ::std::string* RecallRequest::add_tokens() {
  // @@protoc_insertion_point(field_add_mutable:NLP.RecallRequest.tokens)
  return tokens_.Add();
}
inline void RecallRequest::add_tokens(const ::std::string& value) {
  tokens_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:NLP.RecallRequest.tokens)
}
#if LANG_CXX11
inline void RecallRequest::add_tokens(::std::string&& value) {
  tokens_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:NLP.RecallRequest.tokens)
}
#endif
inline void RecallRequest::add_tokens(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  tokens_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:NLP.RecallRequest.tokens)
}
inline void RecallRequest::add_tokens(const char* value, size_t size) {
  tokens_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:NLP.RecallRequest.tokens)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RecallRequest::tokens() const {
  // @@protoc_insertion_point(field_list:NLP.RecallRequest.tokens)
  return tokens_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RecallRequest::mutable_tokens() {
  // @@protoc_insertion_point(field_mutable_list:NLP.RecallRequest.tokens)
  return &tokens_;
}

// -------------------------------------------------------------------

// RecallResponse

// repeated int32 DocIds = 1;
inline int RecallResponse::docids_size() const {
  return docids_.size();
}
inline void RecallResponse::clear_docids() {
  docids_.Clear();
}
inline ::google::protobuf::int32 RecallResponse::docids(int index) const {
  // @@protoc_insertion_point(field_get:NLP.RecallResponse.DocIds)
  return docids_.Get(index);
}
inline void RecallResponse::set_docids(int index, ::google::protobuf::int32 value) {
  docids_.Set(index, value);
  // @@protoc_insertion_point(field_set:NLP.RecallResponse.DocIds)
}
inline void RecallResponse::add_docids(::google::protobuf::int32 value) {
  docids_.Add(value);
  // @@protoc_insertion_point(field_add:NLP.RecallResponse.DocIds)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
RecallResponse::docids() const {
  // @@protoc_insertion_point(field_list:NLP.RecallResponse.DocIds)
  return docids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
RecallResponse::mutable_docids() {
  // @@protoc_insertion_point(field_mutable_list:NLP.RecallResponse.DocIds)
  return &docids_;
}

// -------------------------------------------------------------------

// SortRequest

// repeated .NLP.SegmentResult cut_result = 1;
inline int SortRequest::cut_result_size() const {
  return cut_result_.size();
}
inline void SortRequest::clear_cut_result() {
  cut_result_.Clear();
}
inline ::NLP::SegmentResult* SortRequest::mutable_cut_result(int index) {
  // @@protoc_insertion_point(field_mutable:NLP.SortRequest.cut_result)
  return cut_result_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NLP::SegmentResult >*
SortRequest::mutable_cut_result() {
  // @@protoc_insertion_point(field_mutable_list:NLP.SortRequest.cut_result)
  return &cut_result_;
}
inline const ::NLP::SegmentResult& SortRequest::cut_result(int index) const {
  // @@protoc_insertion_point(field_get:NLP.SortRequest.cut_result)
  return cut_result_.Get(index);
}
inline ::NLP::SegmentResult* SortRequest::add_cut_result() {
  // @@protoc_insertion_point(field_add:NLP.SortRequest.cut_result)
  return cut_result_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NLP::SegmentResult >&
SortRequest::cut_result() const {
  // @@protoc_insertion_point(field_list:NLP.SortRequest.cut_result)
  return cut_result_;
}

// repeated int32 DocIds = 2;
inline int SortRequest::docids_size() const {
  return docids_.size();
}
inline void SortRequest::clear_docids() {
  docids_.Clear();
}
inline ::google::protobuf::int32 SortRequest::docids(int index) const {
  // @@protoc_insertion_point(field_get:NLP.SortRequest.DocIds)
  return docids_.Get(index);
}
inline void SortRequest::set_docids(int index, ::google::protobuf::int32 value) {
  docids_.Set(index, value);
  // @@protoc_insertion_point(field_set:NLP.SortRequest.DocIds)
}
inline void SortRequest::add_docids(::google::protobuf::int32 value) {
  docids_.Add(value);
  // @@protoc_insertion_point(field_add:NLP.SortRequest.DocIds)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
SortRequest::docids() const {
  // @@protoc_insertion_point(field_list:NLP.SortRequest.DocIds)
  return docids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
SortRequest::mutable_docids() {
  // @@protoc_insertion_point(field_mutable_list:NLP.SortRequest.DocIds)
  return &docids_;
}

// -------------------------------------------------------------------

// SortResponse

// repeated int32 DocIds = 1;
inline int SortResponse::docids_size() const {
  return docids_.size();
}
inline void SortResponse::clear_docids() {
  docids_.Clear();
}
inline ::google::protobuf::int32 SortResponse::docids(int index) const {
  // @@protoc_insertion_point(field_get:NLP.SortResponse.DocIds)
  return docids_.Get(index);
}
inline void SortResponse::set_docids(int index, ::google::protobuf::int32 value) {
  docids_.Set(index, value);
  // @@protoc_insertion_point(field_set:NLP.SortResponse.DocIds)
}
inline void SortResponse::add_docids(::google::protobuf::int32 value) {
  docids_.Add(value);
  // @@protoc_insertion_point(field_add:NLP.SortResponse.DocIds)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
SortResponse::docids() const {
  // @@protoc_insertion_point(field_list:NLP.SortResponse.DocIds)
  return docids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
SortResponse::mutable_docids() {
  // @@protoc_insertion_point(field_mutable_list:NLP.SortResponse.DocIds)
  return &docids_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace NLP

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_base_5fservice_2eproto
